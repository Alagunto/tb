---
description: Pre-Implementation Planning Workflow - Enforce deliberate planning before coding
alwaysApply: true
---

# Pre-Implementation Planning Workflow

Before implementing any complex task, you MUST create a detailed implementation plan using a specialized planning agent. This prevents rushed implementation and architectural mistakes.

## When to Trigger Planning

You MUST invoke the planning agent when ANY of these conditions are met:

1. **Multi-File Changes**: Task requires modifying or creating 3+ files
2. **Architectural Decisions**: Task involves choosing between design patterns or architectures
3. **New Features**: User requests a new feature or capability
4. **External Dependencies**: Task requires adding new libraries or external services
5. **API Changes**: Task involves creating or modifying public APIs, endpoints, or contracts
6. **Database Changes**: Task involves schema migrations or data model changes
7. **Refactoring**: Task involves restructuring existing code across multiple modules
8. **Unclear Requirements**: Task description is ambiguous or missing key details

## Planning Agent Invocation

When planning is triggered, execute the following command:

```bash
cursor-agent -p "Analyze the codebase and create a detailed implementation plan for: [TASK_DESCRIPTION]

Include the following sections in your plan:

1. **Overview**: Brief summary of what needs to be accomplished

2. **Files to Modify/Create**: Complete list with specific changes
   - Existing files to modify (with specific functions/sections)
   - New files to create (with purpose and key components)

3. **Architecture Considerations**:
   - Design patterns to use
   - Integration points with existing code
   - Dependencies and coupling analysis
   - Scalability and extensibility considerations

4. **Implementation Steps**: Ordered sequence of changes
   - Step-by-step breakdown
   - Dependencies between steps
   - Critical path identification

5. **Edge Cases and Error Handling**:
   - Input validation requirements
   - Error scenarios to handle
   - Boundary conditions
   - Race conditions or concurrency concerns

6. **Testing Strategy**:
   - Unit tests needed
   - Integration tests needed
   - Edge cases to test
   - Property-based testing opportunities

7. **Security Implications**:
   - Authentication/authorization requirements
   - Input validation and sanitization needs
   - Data exposure risks
   - Cryptographic requirements

8. **Performance Considerations**:
   - Potential bottlenecks
   - Optimization opportunities
   - Resource usage estimates

9. **Rollback Plan**: How to undo changes if something goes wrong

10. **Success Criteria**: How to verify the implementation is complete and correct

Use chain-of-thought reasoning. Think step by step." --model ${CURSOR_PLANNING_MODEL:-sonnet-4.5-thinking} --print
```

## Processing the Plan

After the planning agent returns results:

1. **Parse the Output**: Extract each section systematically
2. **Present to User**: Show the complete plan in a formatted, readable way
3. **Request Approval**: Ask: "I've created a detailed implementation plan. Please review it. Should I proceed with implementation, or would you like me to adjust the plan?"
4. **Wait for Confirmation**: Do NOT start implementation until user approves
5. **Document the Plan**: Save the approved plan to `.cursor/project-state.md` under a new task entry

## Plan Format Template

Present the plan to the user in this format:

```markdown
# Implementation Plan: [Task Name]

## üìã Overview
[Brief summary]

## üìÅ Files to Modify/Create
### Modify:
- `path/to/file1.ext`: [specific changes]
- `path/to/file2.ext`: [specific changes]

### Create:
- `path/to/newfile.ext`: [purpose and key components]

## üèóÔ∏è Architecture Considerations
[Design decisions and patterns]

## üî¢ Implementation Steps
1. [Step 1]
2. [Step 2]
3. [Step 3]
...

## ‚ö†Ô∏è Edge Cases & Error Handling
- [Edge case 1]
- [Edge case 2]
...

## üß™ Testing Strategy
- Unit tests: [list]
- Integration tests: [list]
- Edge case tests: [list]

## üîí Security Implications
- [Security consideration 1]
- [Security consideration 2]
...

## ‚ö° Performance Considerations
- [Performance note 1]
- [Performance note 2]
...

## üîÑ Rollback Plan
[How to undo if needed]

## ‚úÖ Success Criteria
- [ ] Criterion 1
- [ ] Criterion 2
...
```

## Example Usage

**User Request**: "Add user authentication with JWT tokens"

**Your Action**:
1. Recognize this as a complex task requiring planning (security, multi-file, architecture)
2. Invoke planning agent with the detailed prompt
3. Receive and parse the plan
4. Present formatted plan to user
5. Wait for approval
6. Only after approval, begin implementation following the plan

## Integration with Other Rules

- **After Plan Approval**: Proceed to implementation
- **During Implementation**: Reference the plan to stay on track
- **After Implementation**: Trigger review workflow (see 02-review-workflow.mdc)
- **If Plan Changes**: Re-invoke planning agent for significant deviations

## Handling Simple Tasks

For simple tasks that DON'T require planning (single file, minor change, clear requirements):
- Briefly explain what you'll do
- Ask for confirmation: "I'll [action]. Does this approach sound good?"
- Proceed after confirmation

## Notes

- Planning prevents costly mistakes and rework
- Chain-of-thought reasoning in planning agent improves quality
- User review of plans builds trust and catches misunderstandings early
- Well-documented plans serve as implementation guides and documentation
- Plans can be referenced in future similar tasks
