---
description: Context Engineering - Manage context windows and maintain focus
alwaysApply: true
---

# Context Engineering

LLMs have limited context windows and lose focus as conversations grow. This rule enforces structured context management to maintain clarity, prevent context bloat, and ensure the agent remembers important project state across sessions.

## The Context Problem

**Issues with Unlimited Context Accumulation**:
- Agent forgets patterns established earlier
- Inconsistent code generation as conversation progresses
- Reduced accuracy after 50-100 messages
- Expensive token costs
- Slower response times
- Confusion from conflicting information

**Solution**: Structured context compression and state management

## Context Management Strategies

### 1. Project State File

Maintain `.cursor/project-state.md` with structured, compressed project information:

```markdown
# Project State

Last Updated: [TIMESTAMP]

## Current Focus
- Working on: [current task]
- Branch: [git branch]
- Recent changes: [brief summary]

## Active Tasks
### Task 1: [Name]
- Status: In Progress
- Files: [list]
- Next steps: [list]
- Blockers: [if any]

## Project Structure
[Brief overview of key directories and their purposes]

## Key Patterns and Conventions
- Error handling: [pattern]
- Testing approach: [pattern]
- Naming conventions: [rules]
- Architecture: [key decisions]

## Recent Decisions
### [Date]: [Decision]
- Context: [why this was needed]
- Decision: [what was decided]
- Rationale: [why this approach]
- Alternatives considered: [what else was evaluated]

## Known Issues
- Issue 1: [description and status]
- Issue 2: [description and status]

## Dependencies and Configuration
- Key dependencies: [list]
- Environment variables: [list]
- Configuration files: [locations]

## Testing Strategy
- Unit tests: [location and conventions]
- Integration tests: [approach]
- Test data: [location]
```

### 2. Periodic Context Compression

**When to Compress**:
- After completing major features
- Every 50-100 messages in conversation
- When switching between unrelated tasks
- At the end of coding sessions

**How to Compress**:

```bash
cursor-agent -p "Summarize the work completed in this session.

Include:
1. What was implemented/changed
2. Key decisions made and why
3. Patterns established
4. Issues encountered and resolved
5. Remaining work
6. Important context for next session

Be concise but preserve critical information. Format as structured markdown suitable for .cursor/project-state.md" --model ${CURSOR_REVIEW_MODEL:-gpt-5-codex-high} --print
```

Save output to `.cursor/project-state.md`

### 3. Start-of-Session Context Loading

At the beginning of each session, read and provide key context:

```
When starting a new session:
1. Read .cursor/project-state.md
2. Read .cursor/improvement-log.md (recent entries)
3. Check git status for uncommitted changes
4. Review recent commits (last 5)
5. Summarize state to user: "Welcome back! Last session you were working on [X]. Current state: [Y]. Shall we continue?"
```

### 4. Task-Specific Context Isolation

For isolated tasks, use specialized sub-agents with clean context:

**Example - Database Migration**:
```bash
cursor-agent -p "Create a database migration for [change].

Context needed:
- Database: [type]
- Current schema: [relevant tables]
- ORM: [if applicable]
- Migration tool: [tool]

Generate migration with up/down functions following project conventions." --model ${CURSOR_REVIEW_MODEL:-gpt-5-codex-high} --print
```

This agent has ONLY migration-relevant context, avoiding confusion from unrelated code.

### 5. Memory Bank Pattern

Organize knowledge in structured memory banks:

**`.cursor/memory/`**:
- `patterns.md`: Coding patterns and conventions
- `decisions.md`: Architectural decisions log (ADR-style)
- `gotchas.md`: Known pitfalls and how to avoid them
- `snippets.md`: Useful code snippets for common tasks

**Update After Learning**:
When you discover new patterns or make important decisions, update memory banks:

```bash
echo "## Pattern: [Name]
Description: [what it is]
When to use: [scenarios]
Example: [code]
Rationale: [why this approach]
" >> .cursor/memory/patterns.md
```

### 6. Context Pruning

**What to Prune**:
- Detailed implementation discussions (keep decisions, prune exploration)
- Resolved error messages and debugging logs
- Redundant explanations
- Superseded approaches

**What to Keep**:
- Architectural decisions and rationale
- Established patterns and conventions
- Critical constraints and requirements
- Integration points and dependencies
- Known issues and workarounds

## Context Budget Management

**Token Budget Awareness**:
- Sonnet 4.5: 200K tokens context (best consistency)
- GPT-5: 400K tokens context
- Grok 3: 1M token context

**Monitoring Context Usage**:
```
Rough estimates:
- 1 token ≈ 4 characters
- Average code line ≈ 20-30 tokens
- 1000 line file ≈ 20-30k tokens
- Full conversation (100 messages) ≈ 50-100k tokens
```

**Context Allocation Strategy**:
- 30% for conversation history
- 30% for relevant code files
- 20% for project state and patterns
- 20% reserve for agent reasoning

## Conversation Management

### Start Fresh When Appropriate

**Start New Conversation For**:
- New features unrelated to current work
- After completing a major milestone
- When context becomes confused/contradictory
- After error cascades (multiple failed attempts)

**Before Starting Fresh**:
1. Save important context to project-state.md
2. Document decisions in memory banks
3. Commit code changes
4. Update improvement log

### Conversation Checkpoints

Every 20-30 messages, create a checkpoint:

```markdown
## Checkpoint: [TIMESTAMP]

**Completed**:
- [Item 1]
- [Item 2]

**Current State**:
- Working on: [task]
- Next steps: [list]

**Decisions Made**:
- [Decision 1 with brief rationale]

**Context to Preserve**:
- [Key information that must be remembered]
```

## Handling Context Overflow

If context window is approaching limits:

### Strategy 1: Summarization
```bash
cursor-agent -p "Summarize our conversation focusing on:
1. Key decisions made
2. Patterns established
3. Current state of implementation
4. Next steps

Be extremely concise. This summary will replace the conversation history." --print
```

### Strategy 2: Aggressive Pruning
- Remove all debugging output
- Remove exploration of abandoned approaches
- Keep only final decisions
- Compress detailed discussions to bullet points

### Strategy 3: Large Context Models
Switch to appropriate model based on context requirements:
```bash
# For 150-400K tokens
cursor-agent -p "[task]" --model gpt-5 --print

# For 400K-1M tokens (massive codebases)
cursor-agent -p "[task]" --model grok --print
```

### Strategy 4: Divide and Conquer
Break task into smaller subtasks that fit in context:
- Task 1: Database layer (small context)
- Task 2: Business logic (small context)
- Task 3: API layer (small context)
- Final: Integration (moderate context)

## AGENTS.md Integration

Create or maintain `AGENTS.md` file with agent-specific documentation:

```markdown
# Agent Context Document

## Quick Start
[Minimal steps to understand and work with this project]

## Project Structure
[Directory layout and purposes]

## Development Workflow
1. [Step 1]
2. [Step 2]
...

## Build and Test
```bash
# Build
[build command]

# Test
[test command]

# Run
[run command]
```

## Code Conventions
- [Convention 1]
- [Convention 2]

## Architecture Decisions
### [Decision 1]
- Context: [problem]
- Decision: [solution]
- Consequences: [implications]

## Common Tasks
### Adding a New Feature
1. [Step 1]
2. [Step 2]

### Debugging Issues
1. [Step 1]
2. [Step 2]

## Gotchas and Pitfalls
- [Gotcha 1 and how to avoid]
- [Gotcha 2 and how to avoid]
```

## Integration with Planning and Review

**Planning Phase**:
- Review project-state.md for context
- Consider active tasks and decisions
- Check for conflicting work

**Review Phase**:
- Verify consistency with established patterns
- Check alignment with previous decisions
- Update project-state.md with new decisions

**After Completion**:
- Compress session context
- Update memory banks
- Clean conversation history

## Context Quality Metrics

Good context management achieves:

✅ Agent maintains consistency across long sessions
✅ Patterns from earlier in conversation are remembered
✅ No redundant explanations needed
✅ Fast response times (not processing huge context)
✅ Cost-effective (not paying for unnecessary tokens)
✅ Clear project state visible at any time
✅ Easy onboarding for new sessions

## Automation

**Automatic Context Compression Script**:

```bash
#!/bin/bash
# .cursor/scripts/compress-context.sh

echo "Compressing context..."

cursor-agent -p "Summarize current project state for .cursor/project-state.md" --print > /tmp/state.md

# Update project-state.md
mv /tmp/state.md .cursor/project-state.md

echo "Context compressed. project-state.md updated."
```

Run after major milestones or every 50 commits.

## Notes

- Context engineering is preventive, not reactive
- Regular compression prevents crisis situations
- Structured state files enable seamless session transitions
- Memory banks create persistent institutional knowledge
- Good context management directly improves code quality
- Agent performance degrades with poor context management
- Invest time in context management to save time in development
- Context is a limited resource - budget it wisely
